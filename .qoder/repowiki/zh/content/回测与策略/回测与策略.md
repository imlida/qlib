# 回测与策略

<cite>
**本文档引用的文件**   
- [account.py](file://qlib/backtest/account.py)
- [executor.py](file://qlib/backtest/executor.py)
- [exchange.py](file://qlib/backtest/exchange.py)
- [position.py](file://qlib/backtest/position.py)
- [rule_strategy.py](file://qlib/contrib/strategy/rule_strategy.py)
- [signal_strategy.py](file://qlib/contrib/strategy/signal_strategy.py)
- [order_generator.py](file://qlib/contrib/strategy/order_generator.py)
- [cost_control.py](file://qlib/contrib/strategy/cost_control.py)
- [enhanced_indexing.py](file://qlib/contrib/strategy/optimizer/enhanced_indexing.py)
- [config_enhanced_indexing.yaml](file://examples/portfolio/config_enhanced_indexing.yaml)
- [prepare_riskdata.py](file://examples/portfolio/prepare_riskdata.py)
</cite>

## 目录
1. [引言](#引言)
2. [Executor执行器设计](#executor执行器设计)
3. [Account账户模型](#account账户模型)
4. [内置策略实现](#内置策略实现)
5. [投资组合优化功能](#投资组合优化功能)
6. [自定义策略开发](#自定义策略开发)
7. [复杂策略应用示例](#复杂策略应用示例)
8. [结论](#结论)

## 引言
本文档详细描述了QLib回测系统和策略引擎的设计与实现。我们将深入分析Executor执行器如何模拟真实交易环境，Account账户模型如何跟踪持仓和资金变化，介绍RuleStrategy和SignalStrategy等内置策略的逻辑与配置方法，说明投资组合优化功能（如增强型指数跟踪）的实现，并提供自定义策略开发的完整示例。

## Executor执行器设计

Executor执行器是QLib回测系统的核心组件，负责模拟真实交易环境的执行过程。执行器通过分层架构设计，能够处理不同频率的交易决策，从日频到分钟频的复杂交易场景。

执行器的主要职责包括：
- 管理交易日历和时间步进
- 执行交易决策并更新账户状态
- 处理嵌套执行逻辑
- 计算交易指标和绩效

执行器的基类`BaseExecutor`定义了执行器的基本接口和通用功能。执行器通过`collect_data`方法实现交易决策的收集和执行，该方法是一个生成器函数，支持在强化学习等场景中进行数据收集。

```mermaid
classDiagram
class BaseExecutor {
+time_per_step : str
+indicator_config : dict
+generate_portfolio_metrics : bool
+verbose : bool
+track_data : bool
+reset_common_infra(common_infra, copy_trade_account) void
+reset(common_infra, **kwargs) void
+execute(trade_decision, level) List[object]
+collect_data(trade_decision, return_value, level) Generator[Any, Any, List[object]]
+get_all_executors() List[BaseExecutor]
}
class NestedExecutor {
+inner_executor : BaseExecutor
+inner_strategy : BaseStrategy
+_skip_empty_decision : bool
+_align_range_limit : bool
+reset_common_infra(common_infra, copy_trade_account) void
+_init_sub_trading(trade_decision) void
+_update_trade_decision(trade_decision) BaseTradeDecision
+_collect_data(trade_decision, level) Generator[Any, Any, Tuple[List[object], dict]]
+post_inner_exe_step(inner_exe_res) void
+get_all_executors() List[BaseExecutor]
}
class SimulatorExecutor {
+TT_SERIAL : str
+TT_PARAL : str
+trade_type : str
+_get_order_iterator(trade_decision) List[Order]
+_collect_data(trade_decision, level) Tuple[List[object], dict]
}
BaseExecutor <|-- NestedExecutor
BaseExecutor <|-- SimulatorExecutor
```

**图源**
- [executor.py](file://qlib/backtest/executor.py#L22-L503)

**本节来源**
- [executor.py](file://qlib/backtest/executor.py#L22-L503)

## Account账户模型

Account账户模型是回测系统中用于跟踪持仓和资金变化的核心组件。账户模型通过Position位置管理器来维护股票持仓、现金和相关指标。

账户模型的主要功能包括：
- 跟踪现金和持仓价值
- 计算累计收益、成本和换手率
- 更新投资组合绩效指标
- 维护历史持仓记录

账户模型通过`AccumulatedInfo`类来管理累计信息，包括累计收益、成本和换手率。这些信息在交易执行过程中不断更新，用于计算投资组合的绩效。

```mermaid
classDiagram
class Account {
+init_cash : float
+current_position : BasePosition
+accum_info : AccumulatedInfo
+portfolio_metrics : PortfolioMetrics
+hist_positions : Dict[pd.Timestamp, BasePosition]
+indicator : Indicator
+init_vars(init_cash, position_dict, freq, benchmark_config) void
+is_port_metr_enabled() bool
+reset_report(freq, benchmark_config) void
+reset(freq, benchmark_config, port_metr_enabled) void
+get_hist_positions() Dict[pd.Timestamp, BasePosition]
+get_cash() float
+_update_state_from_order(order, trade_val, cost, trade_price) void
+update_order(order, trade_val, cost, trade_price) void
+update_current_position(trade_start_time, trade_end_time, trade_exchange) void
+update_portfolio_metrics(trade_start_time, trade_end_time) void
+update_hist_positions(trade_start_time) void
+update_indicator(trade_start_time, trade_exchange, atomic, outer_trade_decision, trade_info, inner_order_indicators, decision_list, indicator_config) void
+update_bar_end(trade_start_time, trade_end_time, trade_exchange, atomic, outer_trade_decision, trade_info, inner_order_indicators, decision_list, indicator_config) void
+get_portfolio_metrics() Tuple[pd.DataFrame, dict]
+get_trade_indicator() Indicator
}
class AccumulatedInfo {
+rtn : float
+cost : float
+to : float
+reset() void
+add_return_value(value) void
+add_cost(value) void
+add_turnover(value) void
+get_return : float
+get_cost : float
+get_turnover : float
}
class BasePosition {
+ST_CASH : str
+ST_NO : str
+_settle_type : str
+position : dict
+fill_stock_value(start_time, freq, last_days) void
+skip_update() bool
+check_stock(stock_id) bool
+update_order(order, trade_val, cost, trade_price) void
+update_stock_price(stock_id, price) void
+calculate_stock_value() float
+calculate_value() float
+get_stock_list() List[str]
+get_stock_price(code) float
+get_stock_amount(code) float
+get_cash(include_settle) float
+get_stock_amount_dict() dict
+get_stock_weight_dict(only_stock) dict
+add_count_all(bar) void
+update_weight_all() void
+settle_start(settle_type) void
+settle_commit() void
}
class Position {
+init_cash : float
+_init_stock(stock_id, amount, price) void
+_buy_stock(stock_id, trade_val, cost, trade_price) void
+_sell_stock(stock_id, trade_val, cost, trade_price) void
+_del_stock(stock_id) void
+check_stock(stock_id) bool
+update_order(order, trade_val, cost, trade_price) void
+update_stock_price(stock_id, price) void
+update_stock_count(stock_id, bar, count) void
+update_stock_weight(stock_id, weight) void
+calculate_stock_value() float
+calculate_value() float
+get_stock_list() List[str]
+get_stock_price(code) float
+get_stock_amount(code) float
+get_stock_count(code, bar) float
+get_stock_weight(code) float
+get_cash(include_settle) float
+get_stock_amount_dict() dict
+get_stock_weight_dict(only_stock) dict
+add_count_all(bar) void
+update_weight_all() void
+settle_start(settle_type) void
+settle_commit() void
}
class InfPosition {
+skip_update() bool
+check_stock(stock_id) bool
+update_order(order, trade_val, cost, trade_price) void
+update_stock_price(stock_id, price) void
+calculate_stock_value() float
+calculate_value() float
+get_stock_list() List[str]
+get_stock_price(code) float
+get_stock_amount(code) float
+get_cash(include_settle) float
+get_stock_amount_dict() dict
+get_stock_weight_dict(only_stock) dict
+add_count_all(bar) void
+update_weight_all() void
+settle_start(settle_type) void
+settle_commit() void
}
Account --> AccumulatedInfo : "has"
Account --> BasePosition : "has"
BasePosition <|-- Position
BasePosition <|-- InfPosition
```

**图源**
- [account.py](file://qlib/backtest/account.py#L71-L418)
- [position.py](file://qlib/backtest/position.py#L16-L566)

**本节来源**
- [account.py](file://qlib/backtest/account.py#L71-L418)
- [position.py](file://qlib/backtest/position.py#L16-L566)

## 内置策略实现

QLib提供了多种内置策略，包括基于规则的策略（RuleStrategy）和基于信号的策略（SignalStrategy）。这些策略为用户提供了灵活的交易决策框架。

### RuleStrategy规则策略

RuleStrategy是一类基于预定义规则的交易策略。这类策略通过简单的逻辑规则来生成交易决策，适用于各种交易场景。

```mermaid
classDiagram
class TWAPStrategy {
+trade_amount_remain : dict
+reset(outer_trade_decision, **kwargs) void
+generate_trade_decision(execute_result) TradeDecisionWO
}
class SBBStrategyBase {
+TREND_MID : int
+TREND_SHORT : int
+TREND_LONG : int
+trade_trend : dict
+trade_amount : dict
+reset(outer_trade_decision, **kwargs) void
+_pred_price_trend(stock_id, pred_start_time, pred_end_time) int
+generate_trade_decision(execute_result) TradeDecisionWO
}
class SBBStrategyEMA {
+instruments : list
+freq : str
+signal : dict
+__init__(outer_trade_decision, instruments, freq, trade_exchange, level_infra, common_infra, **kwargs) void
+_reset_signal() void
+reset_level_infra(level_infra) void
+_pred_price_trend(stock_id, pred_start_time, pred_end_time) int
}
class ACStrategy {
+lamb : float
+eta : float
+window_size : int
+instruments : list
+freq : str
+signal : dict
+__init__(lamb, eta, window_size, outer_trade_decision, instruments, freq, trade_exchange, level_infra, common_infra, **kwargs) void
+_reset_signal() void
+reset_level_infra(level_infra) void
+reset(outer_trade_decision, **kwargs) void
+generate_trade_decision(execute_result) TradeDecisionWO
}
class RandomOrderStrategy {
+sample_ratio : float
+volume_ratio : float
+market : str
+direction : int
+volume : pd.DataFrame
+volume_df : pd.DataFrame
+trade_range : Union[Tuple[int, int], TradeRange]
+__init__(trade_range, sample_ratio, volume_ratio, market, direction, *args, **kwargs) void
+generate_trade_decision(execute_result) TradeDecisionWO
}
class FileOrderStrategy {
+order_df : pd.DataFrame
+trade_range : Union[Tuple[int, int], TradeRange]
+__init__(file, trade_range, *args, **kwargs) void
+generate_trade_decision(execute_result) TradeDecisionWO
}
SBBStrategyBase <|-- SBBStrategyEMA
BaseStrategy <|-- TWAPStrategy
BaseStrategy <|-- SBBStrategyBase
BaseStrategy <|-- ACStrategy
BaseStrategy <|-- RandomOrderStrategy
BaseStrategy <|-- FileOrderStrategy
```

**图源**
- [rule_strategy.py](file://qlib/contrib/strategy/rule_strategy.py#L22-L673)

**本节来源**
- [rule_strategy.py](file://qlib/contrib/strategy/rule_strategy.py#L22-L673)

### SignalStrategy信号策略

SignalStrategy是一类基于预测信号的交易策略。这类策略通过分析市场信号来生成交易决策，适用于量化投资场景。

```mermaid
classDiagram
class BaseSignalStrategy {
+signal : Signal
+risk_degree : float
+get_risk_degree(trade_step) float
+__init__(signal, model, dataset, risk_degree, trade_exchange, level_infra, common_infra, **kwargs) void
}
class TopkDropoutStrategy {
+topk : int
+n_drop : int
+method_sell : str
+method_buy : str
+hold_thresh : int
+only_tradable : bool
+forbid_all_trade_at_limit : bool
+__init__(topk, n_drop, method_sell, method_buy, hold_thresh, only_tradable, forbid_all_trade_at_limit, **kwargs) void
+generate_trade_decision(execute_result) TradeDecisionWO
}
class WeightStrategyBase {
+order_generator : OrderGenerator
+generate_target_weight_position(score, current, trade_start_time, trade_end_time) dict
+generate_trade_decision(execute_result) TradeDecisionWO
+__init__(order_generator_cls_or_obj, **kwargs) void
}
class EnhancedIndexingStrategy {
+riskmodel_root : str
+market : str
+turn_limit : float
+factor_exp_path : str
+factor_cov_path : str
+specific_risk_path : str
+blacklist_path : str
+optimizer : EnhancedIndexingOptimizer
+verbose : bool
+_riskdata_cache : dict
+__init__(riskmodel_root, market, turn_limit, name_mapping, optimizer_kwargs, verbose, **kwargs) void
+get_risk_data(date) tuple
+generate_target_weight_position(score, current, trade_start_time, trade_end_time) dict
}
BaseSignalStrategy <|-- TopkDropoutStrategy
BaseSignalStrategy <|-- WeightStrategyBase
WeightStrategyBase <|-- EnhancedIndexingStrategy
```

**图源**
- [signal_strategy.py](file://qlib/contrib/strategy/signal_strategy.py#L25-L523)

**本节来源**
- [signal_strategy.py](file://qlib/contrib/strategy/signal_strategy.py#L25-L523)

## 投资组合优化功能

QLib提供了强大的投资组合优化功能，特别是增强型指数跟踪策略的实现。该功能通过优化器来实现，能够有效控制跟踪误差并提高超额收益。

### 增强型指数跟踪优化器

增强型指数跟踪优化器通过求解一个凸优化问题来生成最优投资组合。优化器考虑了预期收益、风险因子暴露和跟踪误差等多个因素。

```mermaid
classDiagram
class EnhancedIndexingOptimizer {
+lamb : float
+delta : float
+b_dev : float
+f_dev : Union[List[float], np.ndarray]
+scale_return : bool
+epsilon : float
+solver_kwargs : Dict[str, Any]
+__init__(lamb, delta, b_dev, f_dev, scale_return, epsilon, solver_kwargs) void
+__call__(r, F, cov_b, var_u, w0, wb, mfh, mfs) np.ndarray
}
class BaseOptimizer {
+__call__(**kwargs) np.ndarray
}
BaseOptimizer <|-- EnhancedIndexingOptimizer
```

优化问题的数学形式如下：
- 目标函数：最大化超额收益减去风险惩罚
- 约束条件：权重非负、权重和为1、换手率限制、基准偏离限制、因子偏离限制

**图源**
- [enhanced_indexing.py](file://qlib/contrib/strategy/optimizer/enhanced_indexing.py#L16-L203)

**本节来源**
- [enhanced_indexing.py](file://qlib/contrib/strategy/optimizer/enhanced_indexing.py#L16-L203)

## 自定义策略开发

QLib提供了灵活的接口，支持用户开发自定义策略。用户可以通过继承基类并实现特定方法来创建自己的交易策略。

### 成本控制策略

成本控制是交易策略中的重要环节。QLib通过Exchange组件提供了多种成本控制机制，包括交易成本、最小成本和市场冲击成本。

```mermaid
classDiagram
class SoftTopkStrategy {
+topk : int
+max_sold_weight : float
+risk_degree : float
+buy_method : str
+__init__(model, dataset, topk, order_generator_cls_or_obj, max_sold_weight, risk_degree, buy_method, trade_exchange, level_infra, common_infra, **kwargs) void
+get_risk_degree(trade_step) float
+generate_target_weight_position(score, current, trade_start_time, trade_end_time) dict
}
WeightStrategyBase <|-- SoftTopkStrategy
```

**图源**
- [cost_control.py](file://qlib/contrib/strategy/cost_control.py#L13-L102)

**本节来源**
- [cost_control.py](file://qlib/contrib/strategy/cost_control.py#L13-L102)

### 订单生成器

订单生成器负责将目标权重转换为具体的交易订单。QLib提供了两种订单生成器：带交互的订单生成器和不带交互的订单生成器。

```mermaid
classDiagram
class OrderGenerator {
+generate_order_list_from_target_weight_position(current, trade_exchange, target_weight_position, risk_degree, pred_start_time, pred_end_time, trade_start_time, trade_end_time) list
}
class OrderGenWInteract {
+generate_order_list_from_target_weight_position(current, trade_exchange, target_weight_position, risk_degree, pred_start_time, pred_end_time, trade_start_time, trade_end_time) list
}
class OrderGenWOInteract {
+generate_order_list_from_target_weight_position(current, trade_exchange, target_weight_position, risk_degree, pred_start_time, pred_end_time, trade_start_time, trade_end_time) list
}
OrderGenerator <|-- OrderGenWInteract
OrderGenerator <|-- OrderGenWOInteract
```

**图源**
- [order_generator.py](file://qlib/contrib/strategy/order_generator.py#L14-L219)

**本节来源**
- [order_generator.py](file://qlib/contrib/strategy/order_generator.py#L14-L219)

## 复杂策略应用示例

### 增强型指数跟踪策略示例

增强型指数跟踪策略是一个复杂策略的典型应用。该策略结合了预测模型、风险模型和投资组合优化，实现了对基准指数的超额收益。

```mermaid
sequenceDiagram
participant User as "用户"
participant Workflow as "工作流"
participant Model as "预测模型"
participant RiskModel as "风险模型"
participant Optimizer as "优化器"
participant Executor as "执行器"
participant Account as "账户"
User->>Workflow : 配置策略参数
Workflow->>Model : 训练预测模型
Model-->>Workflow : 生成预测信号
Workflow->>RiskModel : 计算风险数据
RiskModel-->>Workflow : 提供风险因子
Workflow->>Optimizer : 执行投资组合优化
Optimizer-->>Workflow : 生成目标权重
Workflow->>Executor : 执行交易决策
Executor->>Account : 更新账户状态
Account-->>Executor : 返回执行结果
Executor-->>Workflow : 返回绩效指标
Workflow-->>User : 展示回测结果
```

配置文件`config_enhanced_indexing.yaml`定义了增强型指数跟踪策略的完整配置，包括数据源、模型、策略和回测参数。

**图源**
- [config_enhanced_indexing.yaml](file://examples/portfolio/config_enhanced_indexing.yaml#L1-L72)
- [prepare_riskdata.py](file://examples/portfolio/prepare_riskdata.py#L1-L53)

**本节来源**
- [config_enhanced_indexing.yaml](file://examples/portfolio/config_enhanced_indexing.yaml#L1-L72)
- [prepare_riskdata.py](file://examples/portfolio/prepare_riskdata.py#L1-L53)

## 结论
QLib的回测系统和策略引擎提供了完整而灵活的框架，支持从简单规则策略到复杂优化策略的各种交易场景。通过Executor执行器、Account账户模型和多种内置策略的协同工作，用户可以高效地开发和测试量化交易策略。系统的模块化设计和丰富的配置选项使得它能够适应不同的研究和生产需求。